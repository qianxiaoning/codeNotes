普通字符（例如，a 到 z 之间的字母）
特殊字符（称为"元字符"）

? 通配符匹配文件名中的 0 个或 1 个字符
* 通配符匹配零个或多个字符
^ 为匹配输入字符串的开始位置
[0-9]+匹配多个数字， [0-9] 匹配单个数字
abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置
+ 号代表前面的字符必须至少出现一次（1次或多次）
---
普通字符:
没有显式指定为元字符的所有可打印和不可打印字符。包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号

非打印字符:
\cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f 换页符
\n 换行符
\r 回车符
\s 任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t 一个制表符。等价于 \x09 和 \cI。
\v 一个垂直制表符。等价于 \x0b 和 \cK

\w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。

\s 匹配任意的空白符
\s+ 匹配多个任意的空白符

\d 匹配数字

\b 匹配单词的开始或结束

^ 匹配字符串的开始

$ 匹配字符串的结束

\w能不能匹配汉字要视你的操作系统和你的应用环境而定

特殊字符: 有特殊含义的字符
$ 要匹配 $ 字符本身，请使用 \$。
( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用
* 零次或多次
+ 一次或多次
. 除换行符 \n 之外的任何单字符
[ 中括号表达式的开始
? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符
\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符
^ 输入字符串的开始位置。在方括号表达式中使用，此时它表示不接受该字符集合
{ 限定符表达式的开始
| 两项之间的一个选择

限定符:
* 匹配前面的子表达式零次或多次
+ 匹配前面的子表达式一次或多次
? 匹配前面的子表达式零次或一次
{n} n 是一个非负整数。匹配确定的 n 次
{n,} n 是一个非负整数。至少匹配n 次
{n,m} m 和 n 均为非负整数，其中n <= m。

>=两位章节
/Chapter [1-9][0-9]*/
一到两位章节
/Chapter [0-9]{1,2}/
两位章节
/Chapter [1-9][0-9]?/
/Chapter [1-9][0-9]{0,1}/

定位符：
^ 开始
$ 结尾
\b 匹配一个单词边界，即字与空格间的位置。
\B 非单词边界匹配。

选择:
:
用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。

其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

反向引用:

前瞻：
exp1(?=exp2) 查找exp2前面的exp1
后顾：
(?<=exp2)exp1 查找exp2后面的exp1
负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
负后顾：
(?<!=exp2)exp1 查找前面不是exp2的exp1

非捕获 ?:和?= 和 ?!
?=正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串
?!负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。

[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符

数字每三位加逗号
(number).toString().replace(/(\d)(?=(?:\d{3})+$)/g, '$1,');

string.replace(//g,''); //全局替换
string.replace(//i,''); //区分大小写

input输入框去除
value = value.toString();
value = value.replace(/[^\-?\d.]/g, "");  //清除“数字”和“.”以外的字符
value = value.replace(/\.{2,}/g, "."); //只保留第一个. 清除多余的
value = value.replace(/\-{1,}/g, "-"); //只保留第一个- 清除多余的
value = value.replace(".", "$#$").replace(/\./g, "").replace("$#$", ".");
value = value.replace(/^(\-)*(\d+)\.(\d\d).*$/, '$1$2.$3');//只能输入两个小数
if (value.indexOf(".") < 0 && valid(value)) {//以上已经过滤，此处控制的是如果没有小数点，首位不能为类似于 01、02的金额
    value = parseFloat(value).toString();
}
-----易懂模式-------------------------
k k

abc abc

[abc] a,b,c

[abc][123] a1,c2,b3,a2,b2,c1

[a-z] 小写字母

[a-zA-Z_0-9] a,A,8,_

[^a-zA-Z] 排除英文字母 9,中,#

[\u4e00-\u9fa5] 中文

\d 数字[0-9]

\D 排除数字[^0-9]

\w 单词字符[a-zA-Z_0-9]

\W 排除单词字符

\s 空白字符

\S 排除空白字符

. 任意字符

[abc]? ?是0或1个 a,b,,c

[abc]?[123] a3,b1,c2,2

[abc]* *是0 到 多 个 a,,abccabaccbbcccabc

[abc]+ +是1 到 多 个 a,b,abaccbccbabacb

[abc]{3} 3个 aaa,bbb,abc,cca

[abc]{3,5} 3到5个 abc,abca,abcab

[abc]{3,} 3到多个 abc,abca,babccbcacbca

| 逻辑或

^ 匹配字符串头部位置
[^] 非

$ 配置字符串尾部位置

匹配指定开头结尾
ni开头，hao结尾的字符串
ni.*hao
ni(.*)hao
------------------
只允许字母、下划线，和一个小数点
/^(?!.*?[.]{2})[a-zA-Z_.]+$/.test("__ddd.dds2")
只允许字母、下划线，和一个小数点，且首尾不能是小数点
/^(?!\.)(?!.*\.$)(?!.*?\.\.)[a-zA-Z_.]+$/.test("__ddd.dds2")
------------------
排除指定：
负向前行断言 (?!)

(?!xxx) // 排除xxx

判断某字符是否是非数字非特殊字符，但可以是下划线_

/[\W\d](?!_)/.test("1"); // true
/[\W\d](?!_)/.test("*"); // true
/[\W\d](?!_)/.test("_"); // false
------------------
提取${}中的字符
function extractContentWithinBraces(str) {
    const regex = /\$\{([^}]+)\}/g;
    let match;
    const result = [];
 
    while ((match = regex.exec(str))) {
        result.push(match[1]); // 添加匹配到的内容到结果数组中
    }
 
    return result;
}
 
// 示例使用
const text = "这是一个文本，包含多个占位符，如：${username} 和 ${age}。";
const extractedContent = extractContentWithinBraces(text);
console.log(extractedContent); // ["username", "age"]
------------------