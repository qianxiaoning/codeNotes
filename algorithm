算法：
一、冒泡排序 基本
从头开始循环，每相邻两数比较，把最大的数往最后推，所以必然能得到最大值。
之后每次减少一次循环，因为最大值已经出来了
冒泡排序 优化一
设一个flag，初始为true，if比较里面赋为false，如果没走就是顺序提前对了，走了就是还没对。
代码：
private static void bubblePraA() {
    int[] a = {11,23,55,30,44};
    int isOk = 0;
    System.out.println(Arrays.toString(a));
    // 双循环冒泡法
    for(int i=0;i<a.length-1;i++) {
//				System.out.println(1);
        // 第一次循环肯定能得到最大值，之后循环可以依次减少循环-i
        isOk = 1;
        for(int j=0;j<a.length-i-1;j++) {
            // 前一项都比后一项小就为1，break循环
            if(a[j]>a[j+1]) {
                int t = a[j+1];
                a[j+1] = a[j];
                a[j] = t;
                isOk = 0;
            }
        }
        System.out.println(1);
        if(isOk == 1) {
            break;
        }
    }
    System.out.println(Arrays.toString(a));
}

冒泡排序 优化二
记录最后的交换下标，最后下标后面的都未交换，所以是正确顺序的，后面从第一个循环到下标处即可。
冒泡排序 优化三？
在二的基础上加一遍从后往前的循环，确定最小值交换下标，这样之后循环起点位置也从最小值下标开始。

二、快速排序 基本
下标     0,1,2,3,4
         k       
数组a = [2,4,6,1,3];
1.i取头下标，j取尾下标，k存头值
i = 0;
j = 4;
k = 2;
2.从j位递减找，<=2的数，找到后a[j]和a[i]的值换位，更新j值
         <=  j
下标     0,1,2,3,4
               k
数组a = [1,4,6,2,3];
i = 0;
j = 3;
k = 2;
3.从i递加找，>=2的数，找到后a[i]和a[j]的值换位，更新i值
         => i
下标     0,1,2,3,4
           k    
数组a = [1,2,6,4,3];
i = 1;
j = 3;
k = 2;
4.从j位递减找，<=2的数，找到后a[j]和a[i]的值换位，更新j值
         <=  j
下标     0,1,2,3,4
           k    
数组a = [1,2,6,4,3];
i = 1;
j = 1;
k = 2;
5.重复2,3直到a[i]==a[j]==k
此时k左边的数都比k小，k右边的数都比k大
6.再次对k左和k右进行 左右数组快速排序，直到分出的数组中只有一个数，不能再分为止。最后得到正确结果。

三、选择排序
感觉和冒泡排序的区别：
就是同样是n-1次循环，每次循环数少一
冒泡是不断两个两个互相赋值，直到最后
选择是把最值下标记住，最后只和起始位置交换赋值一次

基本思路:
从左往右，两两比较，把最小值下标存于变量m，一轮比较完，把最小值和第一个数交换位置。
第二轮在剩下的数中以此类推，把最小值和第二个数交换位置。
直到n和n-1位上的数比较完毕。

第1趟从A[0]~A[n-1]中选取最小值，与A[0]交换；
第2趟从A[1]~A[n-1]中选取最小值，与A[1]交换；
第i趟从A[i-1]~A[n-1]中选取最小值，与A[i-1]交换；

三、归并排序
大概原理
分治：
把数组二分，不断二分至不能二分
对最小数组排序
合并：
把下级两个数组比较，从头开始，如a1[]和a2[]，
a1[0]和a2[0]比，假设a1[0]小，放入新数组，
然后a1[1]和a2[0]比较，如果a2[0]小，再比a1[1]和a2[1];
如果a1[1]小，再比a1[2]和a2[0];以此类推，向上合并